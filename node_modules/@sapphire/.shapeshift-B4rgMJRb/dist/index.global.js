var SapphireShapeshift = (() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + x + '" is not supported');
  });
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // src/index.ts
  var src_exports = {};
  __export(src_exports, {
    BaseError: () => BaseError,
    CombinedError: () => CombinedError,
    CombinedPropertyError: () => CombinedPropertyError,
    ExpectedConstraintError: () => ExpectedConstraintError,
    ExpectedValidationError: () => ExpectedValidationError,
    MissingPropertyError: () => MissingPropertyError,
    MultiplePossibilitiesConstraintError: () => MultiplePossibilitiesConstraintError,
    Result: () => Result,
    UnknownEnumValueError: () => UnknownEnumValueError,
    UnknownPropertyError: () => UnknownPropertyError,
    ValidationError: () => ValidationError,
    customInspectSymbol: () => customInspectSymbol,
    customInspectSymbolStackLess: () => customInspectSymbolStackLess,
    getGlobalValidationEnabled: () => getGlobalValidationEnabled,
    s: () => s,
    setGlobalValidationEnabled: () => setGlobalValidationEnabled
  });

  // src/lib/configs.ts
  var validationEnabled = true;
  function setGlobalValidationEnabled(enabled) {
    validationEnabled = enabled;
  }
  __name(setGlobalValidationEnabled, "setGlobalValidationEnabled");
  function getGlobalValidationEnabled() {
    return validationEnabled;
  }
  __name(getGlobalValidationEnabled, "getGlobalValidationEnabled");

  // src/lib/Result.ts
  var Result = class {
    constructor(success, value, error) {
      this.success = success;
      if (success) {
        this.value = value;
      } else {
        this.error = error;
      }
    }
    isOk() {
      return this.success;
    }
    isErr() {
      return !this.success;
    }
    unwrap() {
      if (this.isOk())
        return this.value;
      throw this.error;
    }
    static ok(value) {
      return new Result(true, value);
    }
    static err(error) {
      return new Result(false, void 0, error);
    }
  };
  __name(Result, "Result");

  // src/validators/BaseValidator.ts
  var BaseValidator = class {
    constructor(constraints = []) {
      this.constraints = [];
      this.isValidationEnabled = null;
      this.constraints = constraints;
    }
    get optional() {
      return new UnionValidator([new LiteralValidator(void 0), this.clone()]);
    }
    get nullable() {
      return new UnionValidator([new LiteralValidator(null), this.clone()]);
    }
    get nullish() {
      return new UnionValidator([new NullishValidator(), this.clone()]);
    }
    get array() {
      return new ArrayValidator(this.clone());
    }
    get set() {
      return new SetValidator(this.clone());
    }
    or(...predicates) {
      return new UnionValidator([this.clone(), ...predicates]);
    }
    transform(cb) {
      return this.addConstraint({ run: (input) => Result.ok(cb(input)) });
    }
    default(value) {
      return new DefaultValidator(this.clone(), value);
    }
    run(value) {
      let result = this.handle(value);
      if (result.isErr())
        return result;
      for (const constraint of this.constraints) {
        result = constraint.run(result.value);
        if (result.isErr())
          break;
      }
      return result;
    }
    parse(value) {
      if (!this.shouldRunConstraints) {
        return this.handle(value).unwrap();
      }
      return this.constraints.reduce((v, constraint) => constraint.run(v).unwrap(), this.handle(value).unwrap());
    }
    setValidationEnabled(isValidationEnabled) {
      const clone = this.clone();
      clone.isValidationEnabled = isValidationEnabled;
      return clone;
    }
    getValidationEnabled() {
      return this.isValidationEnabled;
    }
    get shouldRunConstraints() {
      return this.isValidationEnabled ?? getGlobalValidationEnabled();
    }
    clone() {
      const clone = Reflect.construct(this.constructor, [this.constraints]);
      clone.isValidationEnabled = this.isValidationEnabled;
      return clone;
    }
    addConstraint(constraint) {
      const clone = this.clone();
      clone.constraints = clone.constraints.concat(constraint);
      return clone;
    }
  };
  __name(BaseValidator, "BaseValidator");

  // src/lib/errors/ExpectedConstraintError.ts
  var import_node_util = __require("util");

  // src/lib/errors/BaseError.ts
  var customInspectSymbol = Symbol.for("nodejs.util.inspect.custom");
  var customInspectSymbolStackLess = Symbol.for("nodejs.util.inspect.custom.stack-less");
  var BaseError = class extends Error {
    [customInspectSymbol](depth, options) {
      return `${this[customInspectSymbolStackLess](depth, options)}
${this.stack.slice(this.stack.indexOf("\n"))}`;
    }
  };
  __name(BaseError, "BaseError");

  // src/lib/errors/BaseConstraintError.ts
  var BaseConstraintError = class extends BaseError {
    constructor(constraint, message, given) {
      super(message);
      this.constraint = constraint;
      this.given = given;
    }
  };
  __name(BaseConstraintError, "BaseConstraintError");

  // src/lib/errors/ExpectedConstraintError.ts
  var ExpectedConstraintError = class extends BaseConstraintError {
    constructor(constraint, message, given, expected) {
      super(constraint, message, given);
      this.expected = expected;
    }
    toJSON() {
      return {
        name: this.name,
        constraint: this.constraint,
        given: this.given,
        expected: this.expected
      };
    }
    [customInspectSymbolStackLess](depth, options) {
      const constraint = options.stylize(this.constraint, "string");
      if (depth < 0) {
        return options.stylize(`[ExpectedConstraintError: ${constraint}]`, "special");
      }
      const newOptions = { ...options, depth: options.depth === null ? null : options.depth - 1 };
      const padding = `
  ${options.stylize("|", "undefined")} `;
      const given = (0, import_node_util.inspect)(this.given, newOptions).replaceAll("\n", padding);
      const header = `${options.stylize("ExpectedConstraintError", "special")} > ${constraint}`;
      const message = options.stylize(this.message, "regexp");
      const expectedBlock = `
  ${options.stylize("Expected: ", "string")}${options.stylize(this.expected, "boolean")}`;
      const givenBlock = `
  ${options.stylize("Received:", "regexp")}${padding}${given}`;
      return `${header}
  ${message}
${expectedBlock}
${givenBlock}`;
    }
  };
  __name(ExpectedConstraintError, "ExpectedConstraintError");

  // src/constraints/util/operators.ts
  function lessThan(a, b) {
    return a < b;
  }
  __name(lessThan, "lessThan");
  function lessThanOrEqual(a, b) {
    return a <= b;
  }
  __name(lessThanOrEqual, "lessThanOrEqual");
  function greaterThan(a, b) {
    return a > b;
  }
  __name(greaterThan, "greaterThan");
  function greaterThanOrEqual(a, b) {
    return a >= b;
  }
  __name(greaterThanOrEqual, "greaterThanOrEqual");
  function equal(a, b) {
    return a === b;
  }
  __name(equal, "equal");
  function notEqual(a, b) {
    return a !== b;
  }
  __name(notEqual, "notEqual");

  // src/constraints/ArrayLengthConstraints.ts
  function arrayLengthComparator(comparator, name, expected, length) {
    return {
      run(input) {
        return comparator(input.length, length) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, "Invalid Array length", input, expected));
      }
    };
  }
  __name(arrayLengthComparator, "arrayLengthComparator");
  function arrayLengthLessThan(value) {
    const expected = `expected.length < ${value}`;
    return arrayLengthComparator(lessThan, "s.array(T).lengthLessThan", expected, value);
  }
  __name(arrayLengthLessThan, "arrayLengthLessThan");
  function arrayLengthLessThanOrEqual(value) {
    const expected = `expected.length <= ${value}`;
    return arrayLengthComparator(lessThanOrEqual, "s.array(T).lengthLessThanOrEqual", expected, value);
  }
  __name(arrayLengthLessThanOrEqual, "arrayLengthLessThanOrEqual");
  function arrayLengthGreaterThan(value) {
    const expected = `expected.length > ${value}`;
    return arrayLengthComparator(greaterThan, "s.array(T).lengthGreaterThan", expected, value);
  }
  __name(arrayLengthGreaterThan, "arrayLengthGreaterThan");
  function arrayLengthGreaterThanOrEqual(value) {
    const expected = `expected.length >= ${value}`;
    return arrayLengthComparator(greaterThanOrEqual, "s.array(T).lengthGreaterThanOrEqual", expected, value);
  }
  __name(arrayLengthGreaterThanOrEqual, "arrayLengthGreaterThanOrEqual");
  function arrayLengthEqual(value) {
    const expected = `expected.length === ${value}`;
    return arrayLengthComparator(equal, "s.array(T).lengthEqual", expected, value);
  }
  __name(arrayLengthEqual, "arrayLengthEqual");
  function arrayLengthNotEqual(value) {
    const expected = `expected.length !== ${value}`;
    return arrayLengthComparator(notEqual, "s.array(T).lengthNotEqual", expected, value);
  }
  __name(arrayLengthNotEqual, "arrayLengthNotEqual");
  function arrayLengthRange(start, endBefore) {
    const expected = `expected.length >= ${start} && expected.length < ${endBefore}`;
    return {
      run(input) {
        return input.length >= start && input.length < endBefore ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.array(T).lengthRange", "Invalid Array length", input, expected));
      }
    };
  }
  __name(arrayLengthRange, "arrayLengthRange");
  function arrayLengthRangeInclusive(start, end) {
    const expected = `expected.length >= ${start} && expected.length <= ${end}`;
    return {
      run(input) {
        return input.length >= start && input.length <= end ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.array(T).lengthRangeInclusive", "Invalid Array length", input, expected));
      }
    };
  }
  __name(arrayLengthRangeInclusive, "arrayLengthRangeInclusive");
  function arrayLengthRangeExclusive(startAfter, endBefore) {
    const expected = `expected.length > ${startAfter} && expected.length < ${endBefore}`;
    return {
      run(input) {
        return input.length > startAfter && input.length < endBefore ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.array(T).lengthRangeExclusive", "Invalid Array length", input, expected));
      }
    };
  }
  __name(arrayLengthRangeExclusive, "arrayLengthRangeExclusive");

  // src/lib/errors/CombinedPropertyError.ts
  var CombinedPropertyError = class extends BaseError {
    constructor(errors) {
      super("Received one or more errors");
      this.errors = errors;
    }
    [customInspectSymbolStackLess](depth, options) {
      if (depth < 0) {
        return options.stylize("[CombinedPropertyError]", "special");
      }
      const newOptions = { ...options, depth: options.depth === null ? null : options.depth - 1, compact: true };
      const padding = `
  ${options.stylize("|", "undefined")} `;
      const header = `${options.stylize("CombinedPropertyError", "special")} (${options.stylize(this.errors.length.toString(), "number")})`;
      const message = options.stylize(this.message, "regexp");
      const errors = this.errors.map(([key, error]) => {
        const property = CombinedPropertyError.formatProperty(key, options);
        const body = error[customInspectSymbolStackLess](depth - 1, newOptions).replaceAll("\n", padding);
        return `  input${property}${padding}${body}`;
      }).join("\n\n");
      return `${header}
  ${message}

${errors}`;
    }
    static formatProperty(key, options) {
      if (typeof key === "string")
        return options.stylize(`.${key}`, "symbol");
      if (typeof key === "number")
        return `[${options.stylize(key.toString(), "number")}]`;
      return `[${options.stylize("Symbol", "symbol")}(${key.description})]`;
    }
  };
  __name(CombinedPropertyError, "CombinedPropertyError");

  // src/lib/errors/ValidationError.ts
  var import_node_util2 = __require("util");
  var ValidationError = class extends BaseError {
    constructor(validator, message, given) {
      super(message);
      this.validator = validator;
      this.given = given;
    }
    toJSON() {
      return {
        name: this.name,
        validator: this.validator,
        given: this.given
      };
    }
    [customInspectSymbolStackLess](depth, options) {
      const validator = options.stylize(this.validator, "string");
      if (depth < 0) {
        return options.stylize(`[ValidationError: ${validator}]`, "special");
      }
      const newOptions = { ...options, depth: options.depth === null ? null : options.depth - 1, compact: true };
      const padding = `
  ${options.stylize("|", "undefined")} `;
      const given = (0, import_node_util2.inspect)(this.given, newOptions).replaceAll("\n", padding);
      const header = `${options.stylize("ValidationError", "special")} > ${validator}`;
      const message = options.stylize(this.message, "regexp");
      const givenBlock = `
  ${options.stylize("Received:", "regexp")}${padding}${given}`;
      return `${header}
  ${message}
${givenBlock}`;
    }
  };
  __name(ValidationError, "ValidationError");

  // src/validators/ArrayValidator.ts
  var ArrayValidator = class extends BaseValidator {
    constructor(validator, constraints = []) {
      super(constraints);
      this.validator = validator;
    }
    lengthLessThan(length) {
      return this.addConstraint(arrayLengthLessThan(length));
    }
    lengthLessThanOrEqual(length) {
      return this.addConstraint(arrayLengthLessThanOrEqual(length));
    }
    lengthGreaterThan(length) {
      return this.addConstraint(arrayLengthGreaterThan(length));
    }
    lengthGreaterThanOrEqual(length) {
      return this.addConstraint(arrayLengthGreaterThanOrEqual(length));
    }
    lengthEqual(length) {
      return this.addConstraint(arrayLengthEqual(length));
    }
    lengthNotEqual(length) {
      return this.addConstraint(arrayLengthNotEqual(length));
    }
    lengthRange(start, endBefore) {
      return this.addConstraint(arrayLengthRange(start, endBefore));
    }
    lengthRangeInclusive(startAt, endAt) {
      return this.addConstraint(arrayLengthRangeInclusive(startAt, endAt));
    }
    lengthRangeExclusive(startAfter, endBefore) {
      return this.addConstraint(arrayLengthRangeExclusive(startAfter, endBefore));
    }
    clone() {
      return Reflect.construct(this.constructor, [this.validator, this.constraints]);
    }
    handle(values) {
      if (!Array.isArray(values)) {
        return Result.err(new ValidationError("s.array(T)", "Expected an array", values));
      }
      if (!this.shouldRunConstraints) {
        return Result.ok(values);
      }
      const errors = [];
      const transformed = [];
      for (let i = 0; i < values.length; i++) {
        const result = this.validator.run(values[i]);
        if (result.isOk())
          transformed.push(result.value);
        else
          errors.push([i, result.error]);
      }
      return errors.length === 0 ? Result.ok(transformed) : Result.err(new CombinedPropertyError(errors));
    }
  };
  __name(ArrayValidator, "ArrayValidator");

  // src/constraints/BigIntConstraints.ts
  function bigintComparator(comparator, name, expected, number) {
    return {
      run(input) {
        return comparator(input, number) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, "Invalid bigint value", input, expected));
      }
    };
  }
  __name(bigintComparator, "bigintComparator");
  function bigintLessThan(value) {
    const expected = `expected < ${value}n`;
    return bigintComparator(lessThan, "s.bigint.lessThan", expected, value);
  }
  __name(bigintLessThan, "bigintLessThan");
  function bigintLessThanOrEqual(value) {
    const expected = `expected <= ${value}n`;
    return bigintComparator(lessThanOrEqual, "s.bigint.lessThanOrEqual", expected, value);
  }
  __name(bigintLessThanOrEqual, "bigintLessThanOrEqual");
  function bigintGreaterThan(value) {
    const expected = `expected > ${value}n`;
    return bigintComparator(greaterThan, "s.bigint.greaterThan", expected, value);
  }
  __name(bigintGreaterThan, "bigintGreaterThan");
  function bigintGreaterThanOrEqual(value) {
    const expected = `expected >= ${value}n`;
    return bigintComparator(greaterThanOrEqual, "s.bigint.greaterThanOrEqual", expected, value);
  }
  __name(bigintGreaterThanOrEqual, "bigintGreaterThanOrEqual");
  function bigintEqual(value) {
    const expected = `expected === ${value}n`;
    return bigintComparator(equal, "s.bigint.equal", expected, value);
  }
  __name(bigintEqual, "bigintEqual");
  function bigintNotEqual(value) {
    const expected = `expected !== ${value}n`;
    return bigintComparator(notEqual, "s.bigint.notEqual", expected, value);
  }
  __name(bigintNotEqual, "bigintNotEqual");
  function bigintDivisibleBy(divider) {
    const expected = `expected % ${divider}n === 0n`;
    return {
      run(input) {
        return input % divider === 0n ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.bigint.divisibleBy", "BigInt is not divisible", input, expected));
      }
    };
  }
  __name(bigintDivisibleBy, "bigintDivisibleBy");

  // src/validators/BigIntValidator.ts
  var BigIntValidator = class extends BaseValidator {
    lessThan(number) {
      return this.addConstraint(bigintLessThan(number));
    }
    lessThanOrEqual(number) {
      return this.addConstraint(bigintLessThanOrEqual(number));
    }
    greaterThan(number) {
      return this.addConstraint(bigintGreaterThan(number));
    }
    greaterThanOrEqual(number) {
      return this.addConstraint(bigintGreaterThanOrEqual(number));
    }
    equal(number) {
      return this.addConstraint(bigintEqual(number));
    }
    notEqual(number) {
      return this.addConstraint(bigintNotEqual(number));
    }
    get positive() {
      return this.greaterThanOrEqual(0n);
    }
    get negative() {
      return this.lessThan(0n);
    }
    divisibleBy(number) {
      return this.addConstraint(bigintDivisibleBy(number));
    }
    get abs() {
      return this.transform((value) => value < 0 ? -value : value);
    }
    intN(bits) {
      return this.transform((value) => BigInt.asIntN(bits, value));
    }
    uintN(bits) {
      return this.transform((value) => BigInt.asUintN(bits, value));
    }
    handle(value) {
      return typeof value === "bigint" ? Result.ok(value) : Result.err(new ValidationError("s.bigint", "Expected a bigint primitive", value));
    }
  };
  __name(BigIntValidator, "BigIntValidator");

  // src/constraints/BooleanConstraints.ts
  var booleanTrue = {
    run(input) {
      return input ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.boolean.true", "Invalid boolean value", input, "true"));
    }
  };
  var booleanFalse = {
    run(input) {
      return input ? Result.err(new ExpectedConstraintError("s.boolean.false", "Invalid boolean value", input, "false")) : Result.ok(input);
    }
  };

  // src/validators/BooleanValidator.ts
  var BooleanValidator = class extends BaseValidator {
    get true() {
      return this.addConstraint(booleanTrue);
    }
    get false() {
      return this.addConstraint(booleanFalse);
    }
    equal(value) {
      return value ? this.true : this.false;
    }
    notEqual(value) {
      return value ? this.false : this.true;
    }
    handle(value) {
      return typeof value === "boolean" ? Result.ok(value) : Result.err(new ValidationError("s.boolean", "Expected a boolean primitive", value));
    }
  };
  __name(BooleanValidator, "BooleanValidator");

  // src/constraints/DateConstraints.ts
  function dateComparator(comparator, name, expected, number) {
    return {
      run(input) {
        return comparator(input.getTime(), number) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, "Invalid Date value", input, expected));
      }
    };
  }
  __name(dateComparator, "dateComparator");
  function dateLessThan(value) {
    const expected = `expected < ${value.toISOString()}`;
    return dateComparator(lessThan, "s.date.lessThan", expected, value.getTime());
  }
  __name(dateLessThan, "dateLessThan");
  function dateLessThanOrEqual(value) {
    const expected = `expected <= ${value.toISOString()}`;
    return dateComparator(lessThanOrEqual, "s.date.lessThanOrEqual", expected, value.getTime());
  }
  __name(dateLessThanOrEqual, "dateLessThanOrEqual");
  function dateGreaterThan(value) {
    const expected = `expected > ${value.toISOString()}`;
    return dateComparator(greaterThan, "s.date.greaterThan", expected, value.getTime());
  }
  __name(dateGreaterThan, "dateGreaterThan");
  function dateGreaterThanOrEqual(value) {
    const expected = `expected >= ${value.toISOString()}`;
    return dateComparator(greaterThanOrEqual, "s.date.greaterThanOrEqual", expected, value.getTime());
  }
  __name(dateGreaterThanOrEqual, "dateGreaterThanOrEqual");
  function dateEqual(value) {
    const expected = `expected === ${value.toISOString()}`;
    return dateComparator(equal, "s.date.equal", expected, value.getTime());
  }
  __name(dateEqual, "dateEqual");
  function dateNotEqual(value) {
    const expected = `expected !== ${value.toISOString()}`;
    return dateComparator(notEqual, "s.date.notEqual", expected, value.getTime());
  }
  __name(dateNotEqual, "dateNotEqual");
  var dateInvalid = {
    run(input) {
      return Number.isNaN(input.getTime()) ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.date.invalid", "Invalid Date value", input, "expected === NaN"));
    }
  };
  var dateValid = {
    run(input) {
      return Number.isNaN(input.getTime()) ? Result.err(new ExpectedConstraintError("s.date.valid", "Invalid Date value", input, "expected !== NaN")) : Result.ok(input);
    }
  };

  // src/validators/DateValidator.ts
  var DateValidator = class extends BaseValidator {
    lessThan(date) {
      return this.addConstraint(dateLessThan(new Date(date)));
    }
    lessThanOrEqual(date) {
      return this.addConstraint(dateLessThanOrEqual(new Date(date)));
    }
    greaterThan(date) {
      return this.addConstraint(dateGreaterThan(new Date(date)));
    }
    greaterThanOrEqual(date) {
      return this.addConstraint(dateGreaterThanOrEqual(new Date(date)));
    }
    equal(date) {
      const resolved = new Date(date);
      return Number.isNaN(resolved.getTime()) ? this.invalid : this.addConstraint(dateEqual(resolved));
    }
    notEqual(date) {
      const resolved = new Date(date);
      return Number.isNaN(resolved.getTime()) ? this.valid : this.addConstraint(dateNotEqual(resolved));
    }
    get valid() {
      return this.addConstraint(dateValid);
    }
    get invalid() {
      return this.addConstraint(dateInvalid);
    }
    handle(value) {
      return value instanceof Date ? Result.ok(value) : Result.err(new ValidationError("s.date", "Expected a Date", value));
    }
  };
  __name(DateValidator, "DateValidator");

  // src/lib/errors/ExpectedValidationError.ts
  var import_node_util3 = __require("util");
  var ExpectedValidationError = class extends ValidationError {
    constructor(validator, message, given, expected) {
      super(validator, message, given);
      this.expected = expected;
    }
    toJSON() {
      return {
        name: this.name,
        validator: this.validator,
        given: this.given,
        expected: this.expected
      };
    }
    [customInspectSymbolStackLess](depth, options) {
      const validator = options.stylize(this.validator, "string");
      if (depth < 0) {
        return options.stylize(`[ExpectedValidationError: ${validator}]`, "special");
      }
      const newOptions = { ...options, depth: options.depth === null ? null : options.depth - 1 };
      const padding = `
  ${options.stylize("|", "undefined")} `;
      const expected = (0, import_node_util3.inspect)(this.expected, newOptions).replaceAll("\n", padding);
      const given = (0, import_node_util3.inspect)(this.given, newOptions).replaceAll("\n", padding);
      const header = `${options.stylize("ExpectedValidationError", "special")} > ${validator}`;
      const message = options.stylize(this.message, "regexp");
      const expectedBlock = `
  ${options.stylize("Expected:", "string")}${padding}${expected}`;
      const givenBlock = `
  ${options.stylize("Received:", "regexp")}${padding}${given}`;
      return `${header}
  ${message}
${expectedBlock}
${givenBlock}`;
    }
  };
  __name(ExpectedValidationError, "ExpectedValidationError");

  // src/validators/InstanceValidator.ts
  var InstanceValidator = class extends BaseValidator {
    constructor(expected, constraints = []) {
      super(constraints);
      this.expected = expected;
    }
    handle(value) {
      return value instanceof this.expected ? Result.ok(value) : Result.err(new ExpectedValidationError("s.instance(V)", "Expected", value, this.expected));
    }
    clone() {
      return Reflect.construct(this.constructor, [this.expected, this.constraints]);
    }
  };
  __name(InstanceValidator, "InstanceValidator");

  // src/validators/LiteralValidator.ts
  var LiteralValidator = class extends BaseValidator {
    constructor(literal, constraints = []) {
      super(constraints);
      this.expected = literal;
    }
    handle(value) {
      return Object.is(value, this.expected) ? Result.ok(value) : Result.err(new ExpectedValidationError("s.literal(V)", "Expected values to be equals", value, this.expected));
    }
    clone() {
      return Reflect.construct(this.constructor, [this.expected, this.constraints]);
    }
  };
  __name(LiteralValidator, "LiteralValidator");

  // src/validators/NeverValidator.ts
  var NeverValidator = class extends BaseValidator {
    handle(value) {
      return Result.err(new ValidationError("s.never", "Expected a value to not be passed", value));
    }
  };
  __name(NeverValidator, "NeverValidator");

  // src/validators/NullishValidator.ts
  var NullishValidator = class extends BaseValidator {
    handle(value) {
      return value === void 0 || value === null ? Result.ok(value) : Result.err(new ValidationError("s.nullish", "Expected undefined or null", value));
    }
  };
  __name(NullishValidator, "NullishValidator");

  // src/constraints/NumberConstraints.ts
  function numberComparator(comparator, name, expected, number) {
    return {
      run(input) {
        return comparator(input, number) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, "Invalid number value", input, expected));
      }
    };
  }
  __name(numberComparator, "numberComparator");
  function numberLessThan(value) {
    const expected = `expected < ${value}`;
    return numberComparator(lessThan, "s.number.lessThan", expected, value);
  }
  __name(numberLessThan, "numberLessThan");
  function numberLessThanOrEqual(value) {
    const expected = `expected <= ${value}`;
    return numberComparator(lessThanOrEqual, "s.number.lessThanOrEqual", expected, value);
  }
  __name(numberLessThanOrEqual, "numberLessThanOrEqual");
  function numberGreaterThan(value) {
    const expected = `expected > ${value}`;
    return numberComparator(greaterThan, "s.number.greaterThan", expected, value);
  }
  __name(numberGreaterThan, "numberGreaterThan");
  function numberGreaterThanOrEqual(value) {
    const expected = `expected >= ${value}`;
    return numberComparator(greaterThanOrEqual, "s.number.greaterThanOrEqual", expected, value);
  }
  __name(numberGreaterThanOrEqual, "numberGreaterThanOrEqual");
  function numberEqual(value) {
    const expected = `expected === ${value}`;
    return numberComparator(equal, "s.number.equal", expected, value);
  }
  __name(numberEqual, "numberEqual");
  function numberNotEqual(value) {
    const expected = `expected !== ${value}`;
    return numberComparator(notEqual, "s.number.notEqual", expected, value);
  }
  __name(numberNotEqual, "numberNotEqual");
  var numberInt = {
    run(input) {
      return Number.isInteger(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.number.int", "Given value is not an integer", input, "Number.isInteger(expected) to be true"));
    }
  };
  var numberSafeInt = {
    run(input) {
      return Number.isSafeInteger(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.number.safeInt", "Given value is not a safe integer", input, "Number.isSafeInteger(expected) to be true"));
    }
  };
  var numberFinite = {
    run(input) {
      return Number.isFinite(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.number.finite", "Given value is not finite", input, "Number.isFinite(expected) to be true"));
    }
  };
  var numberNaN = {
    run(input) {
      return Number.isNaN(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.number.equal(NaN)", "Invalid number value", input, "expected === NaN"));
    }
  };
  var numberNotNaN = {
    run(input) {
      return Number.isNaN(input) ? Result.err(new ExpectedConstraintError("s.number.notEqual(NaN)", "Invalid number value", input, "expected !== NaN")) : Result.ok(input);
    }
  };
  function numberDivisibleBy(divider) {
    const expected = `expected % ${divider} === 0`;
    return {
      run(input) {
        return input % divider === 0 ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.number.divisibleBy", "Number is not divisible", input, expected));
      }
    };
  }
  __name(numberDivisibleBy, "numberDivisibleBy");

  // src/validators/NumberValidator.ts
  var NumberValidator = class extends BaseValidator {
    lessThan(number) {
      return this.addConstraint(numberLessThan(number));
    }
    lessThanOrEqual(number) {
      return this.addConstraint(numberLessThanOrEqual(number));
    }
    greaterThan(number) {
      return this.addConstraint(numberGreaterThan(number));
    }
    greaterThanOrEqual(number) {
      return this.addConstraint(numberGreaterThanOrEqual(number));
    }
    equal(number) {
      return Number.isNaN(number) ? this.addConstraint(numberNaN) : this.addConstraint(numberEqual(number));
    }
    notEqual(number) {
      return Number.isNaN(number) ? this.addConstraint(numberNotNaN) : this.addConstraint(numberNotEqual(number));
    }
    get int() {
      return this.addConstraint(numberInt);
    }
    get safeInt() {
      return this.addConstraint(numberSafeInt);
    }
    get finite() {
      return this.addConstraint(numberFinite);
    }
    get positive() {
      return this.greaterThanOrEqual(0);
    }
    get negative() {
      return this.lessThan(0);
    }
    divisibleBy(divider) {
      return this.addConstraint(numberDivisibleBy(divider));
    }
    get abs() {
      return this.transform(Math.abs);
    }
    get sign() {
      return this.transform(Math.sign);
    }
    get trunc() {
      return this.transform(Math.trunc);
    }
    get floor() {
      return this.transform(Math.floor);
    }
    get fround() {
      return this.transform(Math.fround);
    }
    get round() {
      return this.transform(Math.round);
    }
    get ceil() {
      return this.transform(Math.ceil);
    }
    handle(value) {
      return typeof value === "number" ? Result.ok(value) : Result.err(new ValidationError("s.number", "Expected a number primitive", value));
    }
  };
  __name(NumberValidator, "NumberValidator");

  // src/lib/errors/MissingPropertyError.ts
  var MissingPropertyError = class extends BaseError {
    constructor(property) {
      super("A required property is missing");
      this.property = property;
    }
    toJSON() {
      return {
        name: this.name,
        property: this.property
      };
    }
    [customInspectSymbolStackLess](depth, options) {
      const property = options.stylize(this.property.toString(), "string");
      if (depth < 0) {
        return options.stylize(`[MissingPropertyError: ${property}]`, "special");
      }
      const header = `${options.stylize("MissingPropertyError", "special")} > ${property}`;
      const message = options.stylize(this.message, "regexp");
      return `${header}
  ${message}`;
    }
  };
  __name(MissingPropertyError, "MissingPropertyError");

  // src/lib/errors/UnknownPropertyError.ts
  var import_node_util4 = __require("util");
  var UnknownPropertyError = class extends BaseError {
    constructor(property, value) {
      super("Received unexpected property");
      this.property = property;
      this.value = value;
    }
    toJSON() {
      return {
        name: this.name,
        property: this.property,
        value: this.value
      };
    }
    [customInspectSymbolStackLess](depth, options) {
      const property = options.stylize(this.property.toString(), "string");
      if (depth < 0) {
        return options.stylize(`[UnknownPropertyError: ${property}]`, "special");
      }
      const newOptions = { ...options, depth: options.depth === null ? null : options.depth - 1, compact: true };
      const padding = `
  ${options.stylize("|", "undefined")} `;
      const given = (0, import_node_util4.inspect)(this.value, newOptions).replaceAll("\n", padding);
      const header = `${options.stylize("UnknownPropertyError", "special")} > ${property}`;
      const message = options.stylize(this.message, "regexp");
      const givenBlock = `
  ${options.stylize("Received:", "regexp")}${padding}${given}`;
      return `${header}
  ${message}
${givenBlock}`;
    }
  };
  __name(UnknownPropertyError, "UnknownPropertyError");

  // src/validators/util/getV